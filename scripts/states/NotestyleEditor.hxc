import flixel.FlxCamera;
import flixel.FlxState;
import flixel.FlxSprite;
import flixel.FlxG;
import flixel.group.FlxTypedGroup;
import flixel.util.FlxArrayUtil;
import flixel.math.FlxMath;
import flixel.util.FlxSort;
import flixel.util.FlxTimer;

import funkin.Preferences;
import funkin.Conductor;
import funkin.ui.MusicBeatState;
import funkin.ui.mainmenu.MainMenuState;
import funkin.ui.debug.charting.ChartEditorState;
import funkin.graphics.FunkinSprite;
import funkin.input.Cursor;
import funkin.audio.FunkinSound;
import funkin.util.FileUtil;
import funkin.util.ReflectUtil;
import funkin.util.Constants;
import funkin.util.GRhythmUtil;
import funkin.data.notestyle.NoteStyleRegistry;
import funkin.data.song.SongNoteDataRaw;
import funkin.play.notes.notestyle.NoteStyle;
import funkin.play.notes.notekind.NoteKindManager;
import funkin.play.notes.NoteSplash;
import funkin.play.notes.Strumline;
import funkin.play.notes.StrumlineNote;
import funkin.play.notes.NoteHoldCover;
import funkin.play.notes.NoteSprite;
import funkin.modding.events.HitNoteScriptEvent;

import haxe.Json;
import haxe.ui.RuntimeComponentBuilder;
import haxe.ui.components.Label;
import haxe.ui.components.Image;
import haxe.ui.components.Button;
import haxe.ui.components.TabBar;
import haxe.ui.components.Column;
import haxe.ui.components.DropDown;
import haxe.ui.components.TextArea;
import haxe.ui.components.CheckBox;
import haxe.ui.components.TextField;
import haxe.ui.components.ColorPicker;
import haxe.ui.components.NumberStepper;
import haxe.ui.components.pickers.MenuItemPicker;

import haxe.ui.containers.Box;
import haxe.ui.containers.HBox;
import haxe.ui.containers.VBox;
import haxe.ui.containers.Header;
import haxe.ui.containers.TabView;
import haxe.ui.containers.ListView;
import haxe.ui.containers.TableView;
import haxe.ui.containers.TableView;
import haxe.ui.containers.ScrollView;
import haxe.ui.containers.HorizontalSplitter;
import haxe.ui.containers.menus.Menu;
import haxe.ui.containers.menus.MenuBar;
import haxe.ui.containers.menus.MenuItem;
import haxe.ui.containers.menus.MenuCheckBox;
import haxe.ui.containers.menus.MenuOptionBox;
import haxe.ui.containers.menus.MenuSeparator;
import haxe.ui.containers.dialogs.Dialog;
import haxe.ui.containers.dialogs.MessageBox;
import haxe.ui.containers.windows.Window;
import haxe.ui.containers.windows.WindowManager;

import haxe.ui.notifications.NotificationManager;
import haxe.ui.notifications.NotificationType;
import haxe.io.Bytes;

class NotestyleEditor extends MusicBeatState
{
    var windowManager = new WindowManager();
    var notificationManager = new NotificationManager();

    var drumsBG:FunkinSound;

    var testStrumline:Strumline;
    var currentNoteStyleData:NoteStyle;

    var menuBar:MenuBar;
    var saveNotestyleMenuItem:MenuItem;
    var menubarTestCheckbox:MenuCheckBox;

    var localConductor:Conductor;
    var arrowBeat:Float = 0;
    var _lastDirection:Int = 0;
    var _lastBeat:Float = 0;
    var _lastTime:Float = 0;
    var resyncTimer:Float = 0;
    var isTesting:Bool = false;

    var msPerBeat(get, never):Float;
    function get_msPerBeat():Float
    {
        return 60000 / 100;
    }

    public function new()
    {
        super('NotestyleEditor');
    }

    function create():Void
    {
        super.create();

        var chartEditor = new ChartEditorState();
        localConductor = new Conductor();
        localConductor.forceBPM(100);

        drumsBG = FunkinSound.load(Paths.music('offsetsLoop/drumsLoop'), 0, true, false, false, false);

        FlxG.sound.music.fadeOut(0.5, 0, function(tw) {
            FunkinSound.playMusic('offsetsLoop',
            {
                startingVolume: 0,
                overrideExisting: true,
                restartTrack: true,
                loop: true
            });
            drumsBG.play(true);
            FlxG.sound.music.fadeIn(1, 1);
        });

        var floored = Math.floor(localConductor.currentBeatTime);
        arrowBeat = floored - (floored % 4);
        arrowBeat += 4;
        _lastDirection = 0;

        var bg = new FunkinSprite(0, 0).loadGraphic(Paths.image('menuDesat'));
		bg.scrollFactor.set(0, 0);
		bg.setGraphicSize(FlxG.width, FlxG.height);
		bg.updateHitbox();
		bg.screenCenter();
		bg.alpha = 0.25;
		add(bg);

        Cursor.show();

        if (testStrumline != null)
        {
            testStrumline.destroy();
            remove(testStrumline);
        }

        var style = new NoteStyle('pixel');
        currentNoteStyleData = style;
        testStrumline = new Strumline(style);
        testStrumline.screenCenter();
        testStrumline.y = Preferences.downscroll ? FlxG.height - testStrumline.height - Constants.STRUMLINE_Y_OFFSET - noteStyle.getStrumlineOffsets()[1] : Constants.STRUMLINE_Y_OFFSET + 40;
        testStrumline.isDownscroll = Preferences.downscroll;
        testStrumline.scrollFactor.set(0, 0);
        testStrumline.conductorInUse = localConductor;
        // testStrumline.remove(testStrumline.background);
        add(testStrumline);

        testStrumline.clean();
        testStrumline.noteData = [];
        testStrumline.nextNoteIndex = 0;

        menuBar = RuntimeComponentBuilder.build(Paths.ui('notestyle-editor/menubar'));
        add(menuBar);

        menubarTestCheckbox = menuBar.findComponent('menubarTestCheckbox');
        trace(menubarTestCheckbox);
        menubarTestCheckbox.onChange = (event) -> {
            if (menubarTestCheckbox.selected)
            {
                var floored = Math.floor(localConductor.currentBeatTime);
                arrowBeat = floored - (floored % 4);
                arrowBeat += 4;
                _lastDirection = 0;
                isTesting = true;

                drumsBG.pause();
                drumsBG.time = FlxG.sound.music.time;
                drumsBG.resume();
                localConductor.update(FlxG.sound.music.time, true);
                drumsBG.fadeIn(1, 0, 1);
            }
            else
            {
                isTesting = false;
                testStrumline.clean();
                testStrumline.noteData = [];
                testStrumline.nextNoteIndex = 0;
                drumsBG.fadeOut(1, 0);
            }
        }

        notestyleDataWindow = RuntimeComponentBuilder.build(Paths.ui('notestyle-editor/windows/notestyleDataWindow'));
        notestyleDataWindow.windowManager = windowManager;
        add(notestyleDataWindow);

        notestyleDataWindow.x = 5;
        notestyleDataWindow.y = menuBar.height + 5;

        notestyleNoteDataWindow = RuntimeComponentBuilder.build(Paths.ui('notestyle-editor/windows/notestyleNoteDataWindow'));
        notestyleNoteDataWindow.windowManager = windowManager;
        add(notestyleNoteDataWindow);

        notestyleNoteDataWindow.x = 5;
        notestyleNoteDataWindow.y = menuBar.height + notestyleDataWindow.height + 5;
    }

    function update(elapsed:Float):Void
    {
        super.update(elapsed);
        localConductor.update(localConductor.songPosition + elapsed * 1000, false);

        handleKeybinds();

        if (FlxG.sound.music.time < _lastTime)
        {
            localConductor.update(FlxG.sound.music.time, false);
            arrowBeat = 4;

            testStrumline.clean();
            testStrumline.noteData = [];
            testStrumline.nextNoteIndex = 0;
        }

        _lastBeat = localConductor.currentBeatTime;

        resyncTimer += elapsed;
        if (resyncTimer >= 0.5)
        {
            var diff:Float = Math.abs((FlxG.sound.music.time + localConductor.combinedOffset) - localConductor.songPosition);
            var diffBg:Float = Math.abs(FlxG.sound.music.time - drumsBG.time);
            if (diff > 50 || diffBg > 50)
            {
                trace('Resyncing conductor: ' + (diff > diffBg ? diff : diffBg) + 'ms difference');

                // If the difference is greater than 50ms, we resync the conductor.
                localConductor.update(FlxG.sound.music.time, true);
                drumsBG.pause();
                drumsBG.time = FlxG.sound.music.time;
                drumsBG.resume();
                localConductor.currentBeatTime = localConductor.currentBeatTime;
                _lastBeat = localConductor.currentBeatTime;
            }
            resyncTimer = 0;
        }

        _lastTime = FlxG.sound.music.time;

        processNotes();

        if (isTesting)
        {
            while (localConductor.currentBeatTime >= arrowBeat - 2 && localConductor.currentBeatTime < 124)
            {
                arrowBeat = arrowBeat + 1;
                var data:SongNoteDataRaw = new SongNoteDataRaw(arrowBeat * msPerBeat, _lastDirection, 0, null, null);
                testStrumline.addNoteData(data, false);

                _lastDirection = (_lastDirection + 1) % 4; // Cycle through directions 0-3
            }

            if (localConductor.currentBeatTime >= 124 && _lastDirection != 0) _lastDirection = 0; // reset direction on loop
        }

        for (note in testStrumline.notes.members)
        {
            if (note == null || !note.alive) continue;
            var isOffscreen:Bool = testStrumline.isDownscroll ? note.y > FlxG.height : note.y < -note.height;
            if (isOffscreen) testStrumline.killNote(note);
        }
    }

    function handleKeybinds():Void
    {
        if (pressingControl() && FlxG.keys.justPressed.Q) FlxG.switchState(() -> new MainMenuState());
        if (FlxG.keys.justPressed.P) trace(menubarTestCheckbox.value);
        // if (FlxG.keys.justPressed.T)
        // {
        //     if (currentNoteStyleData._data.assets.note.assetPath == "shared:notes")
        //     {
        //         currentNoteStyleData._data.assets.note.assetPath = "week6:weeb/pixelUI/arrows-pixels";
        //     }
        //     else if (currentNoteStyleData._data.assets.note.assetPath == "week6:weeb/pixelUI/arrows-pixels")
        //     {
        //         currentNoteStyleData._data.assets.note.assetPath = "shared:notes";
        //     }

        //     // updateRegularNotes();
        // }
    }

    function pressingControl():Bool
    {
        return FlxG.keys.pressed.CONTROL || FlxG.keys.pressed.WINDOWS;
    }

    function processNotes():Void
    {
        if (testStrumline?.notes?.members == null) return;

        for (note in testStrumline.notes.members)
        {
            if (note == null) continue;
            var r = GRhythmUtil.processWindow(note, false, localConductor);
            if (r.botplayHit)
            {
                var event:NoteScriptEvent = new HitNoteScriptEvent(note, 0.0, 0, 'perfect', false, 0);
                dispatchEvent(event);

                if (event.eventCanceled) continue;

                // Command the opponent to hit the note on time.
                // NOTE: This is what handles the strumline and cleaning up the note itself!
                testStrumline.hitNote(note);
                testStrumline.playNoteSplash(note.noteData.getDirection());

                if (note.holdNoteSprite != null) testStrumline.playNoteHoldCover(note.holdNoteSprite);
            }
        }
    }

    // function updateStrumlineNotes(strumline:Strumline, noteStyle:NoteStyle):Void
    // {
    //     strumline.noteStyle = noteStyle;

	// 	for (i in 0...Strumline.KEY_COUNT)
    //     {
	// 		strumline.strumlineNotes.members[i].kill();
	// 		strumline.strumlineNotes.remove(strumline.strumlineNotes.members[i]);

	// 		var child:StrumlineNote = new StrumlineNote(noteStyle, strumline.isPlayer, Strumline.DIRECTIONS[i]);
	// 		child.x = strumline.getXPos(Strumline.DIRECTIONS[i]);
	// 		child.x += Strumline.INITIAL_OFFSET;
	// 		child.y = 0;

	// 		noteStyle.applyStrumlineOffsets(child);
	// 		strumline.strumlineNotes.add(child);
	// 	}
    // }

    // function updateRegularNotes():Void
    // {
    //     testStrumline.noteStyle = currentNoteStyleData;
	// 	testStrumline.noteSplashes.clear();
    //     currentNoteStyleData.noteFrames = null; // Clear cache

    //     for (note in testStrumline.notes.members)
    //     {
    //         if (note == null) continue;
    //         note.setupNoteGraphic(currentNoteStyleData);
    //         note.playNoteAnimation(note.noteData.getDirection());

    //         note.x = testStrumline.x;
    //         note.x += testStrumline.getXPos(Strumline.DIRECTIONS[note.noteData.getDirection() % Strumline.KEY_COUNT]);
    //         note.x -= (note.width - Strumline.STRUMLINE_SIZE) / 2;
    //         note.x -= 2.0;
    //     }
    // }

    // function updateHoldNotes():Void
    // {
    //     testStrumline.noteStyle = currentNoteStyleData;
	// 	testStrumline.noteHoldCovers.clear();

    //     for (note in testStrumline.notes)
    //     {
    //         if (note.get_isHoldNote())
    //         {
    //             note.holdNoteSprite.setupHoldNoteGraphic(noteStyle);
    //             note.holdNoteSprite.noteStyleOffsets = noteStyle.getHoldNoteOffsets();
    //             note.holdNoteSprite.graphicWidth = note.holdNoteSprite.graphic.width / 8 * note.holdNoteSprite.zoom;
    //             note.holdNoteSprite.graphicHeight = note.holdNoteSprite.sustainLength * Constants.PIXELS_PER_MS * strumline?.scrollSpeed ?? 1.0;

    //             note.holdNoteSprite.updateHitbox();
    //             note.holdNoteSprite.updateClipping();
    //             note.holdNoteSprite.updateColorTransform();

    //             note.holdNoteSprite.x = testStrumline.x;
    //             note.holdNoteSprite.x += testStrumline.getXPos(Strumline.DIRECTIONS[note.noteData.getDirection() % Strumline.KEY_COUNT]);
    //             note.holdNoteSprite.x += Strumline.STRUMLINE_SIZE / 2;
    //             note.holdNoteSprite.x -= note.holdNoteSprite.graphicWidth / 2;

    //             if (note.holdNoteSprite.hitNote) testStrumline.playNoteHoldCover(note.holdNoteSprite);
    //         }
    //     }
    // }
}